using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.IO;
using System.Diagnostics;
using BigFileService;

namespace TFS_Assist
{
    public partial class TSF_Assist : Form
    {
        // This should be the file which would contain all the list of the directories in Server folder.
        // This file will be generated by TF.exe dir /recursive command.
        string directoryListFile = "";
        string batOutputFile = "";
        char[] trimchars = { '/', '\\', ':' };
        string MOCK_FILE = "MOCK_FILE.txt"; // Debug purpose.

        public TSF_Assist()
        {
            InitializeComponent();
#if DEBUG
            cbxNoTFSDEBUG.Visible = true;
            tbxTFSDirPath.Text = @"$/Fusion360Documentation/FusDocMain/acad/develop/global/src";
            tbxMappedFolder.Text = @"F:\Youtube Downloader";
#else
            cbxNoTFSDEBUG.Visible = false;
#endif

            btnRunBat.Enabled = false;
        }

        private void btnGenerateBat_Click(object sender, EventArgs e)
        {
            if (String.IsNullOrEmpty(tbxMappedFolder.Text) || String.IsNullOrEmpty(tbxTFSDirPath.Text))
            {
                MessageBox.Show("Empty source or destination folders");
            }
#if DEBUG
            if (cbxNoTFSDEBUG.Checked)
            {
                TestBigFileDump_File(@"D:\fusion\components\global\src\crxapps\AcFusionService\AcFusionDocInteropStub.cpp", @"H:\");
                return;
            }
#endif
            // Save Last settings.
            Properties.Settings.Default.settingServerFolder = tbxTFSDirPath.Text;
            Properties.Settings.Default.settingLocalFolder = tbxMappedFolder.Text;
            Properties.Settings.Default.Save();

            var batOutFolder = tbxMappedFolder.Text;

            // Disable the buttons.
            btnGenerateBat.Enabled = false;
            btnRunBat.Enabled = false;

            string lastFoldername = GetBatNameFromSource(tbxTFSDirPath.Text);

            directoryListFile = batOutFolder.TrimEnd(trimchars) + "\\" + lastFoldername + "_DIR.txt";

            batOutputFile = batOutFolder.TrimEnd(trimchars) + "\\" + lastFoldername + ".bat";
            lblBatFileInfo.Text = "Check batch file at: " + batOutputFile;

            // Call Tf.exe and get the list of subdirectories. IMP.
            bool success = GenerateDirectoryList(ref directoryListFile, tbxTFSDirPath.Text);

            // delete existing file if any.
            if (File.Exists(batOutputFile) == true)
            {
                File.Delete(batOutputFile);
            }

            // Start processing the input directory file.
            StreamReader reader = new StreamReader(directoryListFile);
            // Create a dump file class object to handle efficient memory management.
            var bigFileDumper = new BigFileDumper(batOutFolder.TrimEnd(trimchars));
            // Reverse the list of commands as we would want the deepest leaf folder to be processed
            // first.
            bigFileDumper.ReverseIt = true;

            string masterFolder = tbxTFSDirPath.Text;
            //var linesToWrite = new List<string>();
            while (reader.EndOfStream == false)
            {
                string line = reader.ReadLine();
                // Now, we will only consider the lines which has full server folder path
                if (cbxRecursive.Checked)
                {
                    if (line.Contains(masterFolder))
                    {
                        line = line.TrimEnd(':');
                        // Add the tf command and option.
                        line = String.Format("TF.exe get {0} ", line); // It's already recursive because all folders are there.
                        // linesToWrite.Add(line);
                        bigFileDumper.WriteLine(line);
                    }
                }
                else
                {
                    if (line.Contains('$') && !line.Contains(masterFolder)) // take only chilren
                    {
                        line = masterFolder + "/" + line.TrimStart('$');
                        // Add the tf command and option.
                        line = String.Format("TF.exe get {0} /recursive", line);
                        //linesToWrite.Add(line);
                        bigFileDumper.WriteLine(line);

                    }
                }               
            }
            bigFileDumper.Close();
            reader.Close();

            // Write the batch file with existing bigFileDumper.
            this.WriteTheBatchFile(ref bigFileDumper);

            btnGenerateBat.Enabled = true;
            btnRunBat.Enabled = true;
            // Open the bat folder
            Process.Start("explorer.exe", tbxMappedFolder.Text);
        }

        private void WriteTheBatchFile(ref BigFileDumper bigFileDumper)
        {
            // Read from the big file.
            string bigFile = bigFileDumper.GetFullFile();
            if (!File.Exists(bigFile))
            {
                MessageBox.Show("Something Went Wrong, no tempFile Generated.");
                return;
            }

            var bigFileReader = new StreamReader(bigFile);

            // Make the output bat file file ready.
            StreamWriter writer = new StreamWriter(batOutputFile);
            // First line is to change to working directory.
            writer.WriteLine("cd " + tbxMappedFolder.Text);
            writer.WriteLine(tbxMappedFolder.Text.Substring(0, 2));
            string echoline = "";
            int count = 0;

            long totalcount = bigFileDumper.TotalLineCount;
            while (!bigFileReader.EndOfStream)
            {
                // Echo line at each 10th folder.
                count++;
                if (count % 10 == 0)
                {
                    echoline = String.Format("echo ********** {0} of {1} FOLDERS UPDATED ***********", count, totalcount);
                    writer.WriteLine(echoline);
                }
                writer.WriteLine(bigFileReader.ReadLine());
            }
            writer.Close();
            bigFileReader.Close();

            // Delete the temporary folders.
            bigFileDumper.CleanEverything();
        }

        private string GetBatNameFromSource(string path)
        {
            string foldername = path.TrimEnd(trimchars); // if any trailing '/'
            foldername = foldername.Substring(path.LastIndexOf('/') + 1);
            return foldername;
        }

        private bool GenerateDirectoryList(ref string directoryListFile, string serverFolderPath)
        {
            if(cbxNoTFSDEBUG.Checked)
            {
                return CopyMockFile(directoryListFile);
            }
            try
            {
                // delete the existing directoryListFile
                if (File.Exists(directoryListFile) == true)
                {
                    File.Delete(directoryListFile);
                }

                var commands = new List<string>();
                // Change directory to mapped folder
                var cmd = String.Format("cd \"{0}\"", tbxMappedFolder.Text);
                commands.Add(cmd);
                commands.Add(tbxMappedFolder.Text.Substring(0, 2)); // example D:
                // Check if it should be made recursive.
                string option = cbxRecursive.Checked ? "/recursive" : "";
                // run the dir command
                cmd = String.Format("TF.exe dir {0} {1} >> \"{2}\"", option, serverFolderPath, directoryListFile);
                commands.Add(cmd);
                RunOnCmdLine(ref commands);
            }
            catch (Exception e)
            {
                MessageBox.Show(e.Message);
                throw e;
            }
            return true;         
        }

        private bool CopyMockFile(string directoryListFile)
        {
            File.Copy(MOCK_FILE, directoryListFile, true);
            return true;
        }

        private void RunOnCmdLine(ref List<string> mycmd)
        {
            //http://stackoverflow.com/questions/1469764/run-command-prompt-commands Ogglas' answer.
            try
            {
                Process cmd = new Process();
                cmd.StartInfo.FileName = "cmd.exe";
                cmd.StartInfo.RedirectStandardInput = true;
                cmd.StartInfo.RedirectStandardOutput = true;
                cmd.StartInfo.CreateNoWindow = false;
                cmd.StartInfo.UseShellExecute = false;
                cmd.Start();
                foreach (var item in mycmd)
                {
                    cmd.StandardInput.WriteLine(item);
                }
                cmd.StandardInput.Flush();
                cmd.StandardInput.Close();
                cmd.WaitForExit();
                Console.WriteLine(cmd.StandardOutput.ReadToEnd());
            }
            catch (Exception e)
            {
                MessageBox.Show(e.Message);
                throw e;
            }
        }

        private void btnRunBat_Click(object sender, EventArgs e)
        {
            Process.Start(this.batOutputFile);
        }

        private void bthHelp_Click(object sender, EventArgs e)
        {
            var msg = "TF.exe path should be included in your path system variable.\n" + 
                "% ProgramFiles(x86) %\\Microsoft Visual Studio XX\\Common7\\IDE. \n" + 
                "The mapped folder need not point to the exact location. It could be any folder as such.\n"+
                "Check generated batch file before running it.";
            MessageBox.Show(msg, "Info", MessageBoxButtons.OK);
        }
        private void TestBigFileDump(string foldername)
        {
            if (Directory.Exists(foldername))
            {

                var bigfileDumper = new BigFileDumper(foldername);
                bigfileDumper.ReverseIt = true;

                for (int i = 0; i < 10000; i++)
                {
                    bigfileDumper.WriteLine(String.Format("{0}", i));
                }
                bigfileDumper.Close();

                // Get back full reversed file.
                var reversedFilename = bigfileDumper.GetFullFile();

                Console.WriteLine("Check output file - " + reversedFilename);
            }
            else
                Console.WriteLine("Invalid folder path");
        }

        private void TestBigFileDump_File(string BIG_FILE, string FOLDER_PATH_FOR_CHUNK_FILES)
        {
            // Start processing the input Big file.
            StreamReader reader = new StreamReader(BIG_FILE);
            // Create a dump file class object to handle efficient memory management.
            var bigFileDumper = new BigFileDumper(FOLDER_PATH_FOR_CHUNK_FILES);
            // Reverse the list of commands as we would want the deepest leaf folder to be processed first.
            bigFileDumper.ReverseIt = true;
            bigFileDumper.CHUNK_SIZE = 100; // How much at a time to keep in RAM before dumping to local file.

            while (reader.EndOfStream == false)
            {
                string line = reader.ReadLine();
                bigFileDumper.WriteLine(line);
            }
            bigFileDumper.Close();
            reader.Close();

            // Get back full reversed file.
            var reversedFilename = bigFileDumper.GetFullFile();
            Console.WriteLine("Check output file - " + reversedFilename);

            // Delete the temporary folders.
            bigFileDumper.CleanEverything();

        }
    }
}
